{"ast":null,"code":"import _objectSpread from \"E:/phpDemo/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"E:/phpDemo/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regenerator from \"E:/phpDemo/frontend/node_modules/@babel/runtime/helpers/esm/regenerator.js\";\nimport _asyncToGenerator from \"E:/phpDemo/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport { trackStream } from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport { progressEventReducer, progressEventDecorator, asyncDecorator } from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\nvar isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nvar isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nvar encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? function (encoder) {\n  return function (str) {\n    return encoder.encode(str);\n  };\n}(new TextEncoder()) : (/*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(str) {\n    var _t, _t2;\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.n) {\n        case 0:\n          _t = Uint8Array;\n          _context.n = 1;\n          return new Response(str).arrayBuffer();\n        case 1:\n          _t2 = _context.v;\n          return _context.a(2, new _t(_t2));\n      }\n    }, _callee);\n  }));\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}()));\nvar test = function test(fn) {\n  try {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return !!fn.apply(void 0, args);\n  } catch (e) {\n    return false;\n  }\n};\nvar supportsRequestStream = isReadableStreamSupported && test(function () {\n  var duplexAccessed = false;\n  var hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    }\n  }).headers.has('Content-Type');\n  return duplexAccessed && !hasContentType;\n});\nvar DEFAULT_CHUNK_SIZE = 64 * 1024;\nvar supportsResponseStream = isReadableStreamSupported && test(function () {\n  return utils.isReadableStream(new Response('').body);\n});\nvar resolvers = {\n  stream: supportsResponseStream && function (res) {\n    return res.body;\n  }\n};\nisFetchSupported && function (res) {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(function (type) {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? function (res) {\n      return res[type]();\n    } : function (_, config) {\n      throw new AxiosError(\"Response type '\".concat(type, \"' is not supported\"), AxiosError.ERR_NOT_SUPPORT, config);\n    });\n  });\n}(new Response());\nvar getBodyLength = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(body) {\n    var _request;\n    return _regenerator().w(function (_context2) {\n      while (1) switch (_context2.n) {\n        case 0:\n          if (!(body == null)) {\n            _context2.n = 1;\n            break;\n          }\n          return _context2.a(2, 0);\n        case 1:\n          if (!utils.isBlob(body)) {\n            _context2.n = 2;\n            break;\n          }\n          return _context2.a(2, body.size);\n        case 2:\n          if (!utils.isSpecCompliantForm(body)) {\n            _context2.n = 4;\n            break;\n          }\n          _request = new Request(platform.origin, {\n            method: 'POST',\n            body: body\n          });\n          _context2.n = 3;\n          return _request.arrayBuffer();\n        case 3:\n          return _context2.a(2, _context2.v.byteLength);\n        case 4:\n          if (!(utils.isArrayBufferView(body) || utils.isArrayBuffer(body))) {\n            _context2.n = 5;\n            break;\n          }\n          return _context2.a(2, body.byteLength);\n        case 5:\n          if (utils.isURLSearchParams(body)) {\n            body = body + '';\n          }\n          if (!utils.isString(body)) {\n            _context2.n = 7;\n            break;\n          }\n          _context2.n = 6;\n          return encodeText(body);\n        case 6:\n          return _context2.a(2, _context2.v.byteLength);\n        case 7:\n          return _context2.a(2);\n      }\n    }, _callee2);\n  }));\n  return function getBodyLength(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar resolveBodyLength = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(headers, body) {\n    var length;\n    return _regenerator().w(function (_context3) {\n      while (1) switch (_context3.n) {\n        case 0:\n          length = utils.toFiniteNumber(headers.getContentLength());\n          return _context3.a(2, length == null ? getBodyLength(body) : length);\n      }\n    }, _callee3);\n  }));\n  return function resolveBodyLength(_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport default isFetchSupported && (/*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(config) {\n    var _resolveConfig, url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, _resolveConfig$withCr, withCredentials, fetchOptions, composedSignal, request, unsubscribe, requestContentLength, _request, contentTypeHeader, _progressEventDecorat, _progressEventDecorat2, onProgress, flush, isCredentialsSupported, response, isStreamResponse, options, responseContentLength, _ref5, _ref6, _onProgress, _flush, responseData, _t3, _t4, _t5;\n    return _regenerator().w(function (_context4) {\n      while (1) switch (_context4.n) {\n        case 0:\n          _resolveConfig = resolveConfig(config), url = _resolveConfig.url, method = _resolveConfig.method, data = _resolveConfig.data, signal = _resolveConfig.signal, cancelToken = _resolveConfig.cancelToken, timeout = _resolveConfig.timeout, onDownloadProgress = _resolveConfig.onDownloadProgress, onUploadProgress = _resolveConfig.onUploadProgress, responseType = _resolveConfig.responseType, headers = _resolveConfig.headers, _resolveConfig$withCr = _resolveConfig.withCredentials, withCredentials = _resolveConfig$withCr === void 0 ? 'same-origin' : _resolveConfig$withCr, fetchOptions = _resolveConfig.fetchOptions;\n          responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n          composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n          unsubscribe = composedSignal && composedSignal.unsubscribe && function () {\n            composedSignal.unsubscribe();\n          };\n          _context4.p = 1;\n          _t3 = onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head';\n          if (!_t3) {\n            _context4.n = 3;\n            break;\n          }\n          _context4.n = 2;\n          return resolveBodyLength(headers, data);\n        case 2:\n          _t4 = requestContentLength = _context4.v;\n          _t3 = _t4 !== 0;\n        case 3:\n          if (!_t3) {\n            _context4.n = 4;\n            break;\n          }\n          _request = new Request(url, {\n            method: 'POST',\n            body: data,\n            duplex: \"half\"\n          });\n          if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n            headers.setContentType(contentTypeHeader);\n          }\n          if (_request.body) {\n            _progressEventDecorat = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress))), _progressEventDecorat2 = _slicedToArray(_progressEventDecorat, 2), onProgress = _progressEventDecorat2[0], flush = _progressEventDecorat2[1];\n            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n          }\n        case 4:\n          if (!utils.isString(withCredentials)) {\n            withCredentials = withCredentials ? 'include' : 'omit';\n          }\n\n          // Cloudflare Workers throws when credentials are defined\n          // see https://github.com/cloudflare/workerd/issues/902\n          isCredentialsSupported = \"credentials\" in Request.prototype;\n          request = new Request(url, _objectSpread(_objectSpread({}, fetchOptions), {}, {\n            signal: composedSignal,\n            method: method.toUpperCase(),\n            headers: headers.normalize().toJSON(),\n            body: data,\n            duplex: \"half\",\n            credentials: isCredentialsSupported ? withCredentials : undefined\n          }));\n          _context4.n = 5;\n          return fetch(request);\n        case 5:\n          response = _context4.v;\n          isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {\n            options = {};\n            ['status', 'statusText', 'headers'].forEach(function (prop) {\n              options[prop] = response[prop];\n            });\n            responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n            _ref5 = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [], _ref6 = _slicedToArray(_ref5, 2), _onProgress = _ref6[0], _flush = _ref6[1];\n            response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, _onProgress, function () {\n              _flush && _flush();\n              unsubscribe && unsubscribe();\n            }), options);\n          }\n          responseType = responseType || 'text';\n          _context4.n = 6;\n          return resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n        case 6:\n          responseData = _context4.v;\n          !isStreamResponse && unsubscribe && unsubscribe();\n          _context4.n = 7;\n          return new Promise(function (resolve, reject) {\n            settle(resolve, reject, {\n              data: responseData,\n              headers: AxiosHeaders.from(response.headers),\n              status: response.status,\n              statusText: response.statusText,\n              config: config,\n              request: request\n            });\n          });\n        case 7:\n          return _context4.a(2, _context4.v);\n        case 8:\n          _context4.p = 8;\n          _t5 = _context4.v;\n          unsubscribe && unsubscribe();\n          if (!(_t5 && _t5.name === 'TypeError' && /Load failed|fetch/i.test(_t5.message))) {\n            _context4.n = 9;\n            break;\n          }\n          throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {\n            cause: _t5.cause || _t5\n          });\n        case 9:\n          throw AxiosError.from(_t5, _t5 && _t5.code, config, request);\n        case 10:\n          return _context4.a(2);\n      }\n    }, _callee4, null, [[1, 8]]);\n  }));\n  return function (_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}());","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}